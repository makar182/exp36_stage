# Refactoring and Scalability Suggestions

## Общая оценка
Текущая архитектура основана на разделении по слоям в стиле feature-sliced design и уже достаточно чистая. Корневой компонент `App` только монтирует `HomePage`, а основная бизнес-логика инкапсулирована в хуке `useShortLinks`. Это делает проект понятным для новичков и поддерживаемым при небольшом объёме функциональности. Тем не менее, для дальнейшего роста есть несколько зон, где можно усилить гибкость и повторное использование.

## Возможные улучшения

### 1. Слой данных и управление запросами
* Рассмотреть миграцию логики загрузки/модификации ссылок в специализированную библиотеку для работы с запросами (React Query / TanStack Query или SWR). Хук `useShortLinks` вручную следит за конкурентными запросами, статусами и синхронизацией с локальным состоянием (`refreshRequestIdRef`, сеттеры состояний). Использование React Query позволит получить кеширование, автоматическое повторное выполнение запросов и декларативную работу со статусами без кастомного кода. Актуальные участки: `useShortLinks` и API-слой `src/shared/api/url-shortener.ts`.
* Если React Query кажется избыточным, можно хотя бы вынести управление состояниями загрузки в отдельный reducer, чтобы уменьшить количество разрозненных `useState` и явно описать переходы между состояниями.

### 2. Ошибки и уведомления
* Сейчас текст ошибки хранится в `useShortLinks` и дублируется проверкой в форме (`ShortLinksDashboard`). Для расширения функциональности (например, добавление успех-уведомлений или несколько форм) стоит внедрить единый механизм уведомлений через контекст или менеджер тостов.
* Ошибки из API превращаются в `Error` c сообщением из `response.text()`. Было бы полезно типизировать ответы об ошибках и показывать пользователю локализованные сообщения вместо сырого текста сервера.

### 3. Формы и валидация
* Форма создания ссылки управляется вручную, и `required` на поле URL частично дублирует логику в хуке. Подключение легковесной библиотеки вроде `react-hook-form` или `zod` для схем валидации поможет переиспользовать правила при добавлении, например, формы редактирования.

### 4. Расширяемость UI
* Компонент `ShortLinksDashboard` содержит и форму, и список, и заголовок — более 150 строк JSX. При появлении дополнительных функций (фильтрация, пагинация, аналитика) его стоит разбить на подкомпоненты: `ShortLinksHeader`, `ShortLinkForm`, `ShortLinksList`, `ShortLinkRow`. Это сделает переиспользование и тестирование проще.
* Для skeleton-списка используется `Array.from({ length: 3 })` в `useMemo`, что жёстко ограничивает количество элементов. Можно передавать желаемое количество через пропсы или вычислять его на основе ширины экрана, чтобы skeleton выглядел более естественно.

### 5. Типизация и разделение домена
* Тип `ShortLink` уже описан, но стоит добавить отдельные типы для полезных значений (`ShortLinkId`, `ShortLinkSlug`) и использовать их в API-слое и хуках, чтобы уменьшить риск случайной подмены строк.
* Рассмотреть вынос форматирования дат (`formatDate`) и других util-функций в пакет `entities/short-link/lib`, чтобы связать их с доменной сущностью.

### 6. Работа с буфером обмена
* Сейчас `navigator.clipboard` вызывается без проверки доступности (может отсутствовать в некоторых окружениях Mini App). Можно внедрить graceful fallback (например, копирование через `document.execCommand('copy')` или отображение подсказки пользователю) и оборачивать доступ в отдельный хелпер, чтобы централизованно обрабатывать ограничения Telegram WebView.

### 7. Конфигурация окружения
* Переменные `VITE_API_BASE_URL` и `VITE_SHORT_BASE_URL` обрезаются от завершающих слэшей, но не проверяются на наличие протокола. В документации стоит явно указать, каким должен быть формат значений, либо нормализовать URL через `new URL()` для надёжности.

## План внедрения
1. Внедрить слой запросов (React Query) и адаптировать `useShortLinks` к его API.
2. Разбить `ShortLinksDashboard` на подкомпоненты и вынести форму в отдельный модуль.
3. Добавить глобальный механизм уведомлений/тестов и типизированную обработку ошибок API.
4. Постепенно внедрить схему валидации и дополнительные типы домена.

Такой план позволит наращивать функциональность (редактирование ссылок, статистика по кликам, сохранённые фильтры) без взрывного роста сложности и дублирования логики.
